% Distributed under the MIT License.
% (See accompanying file LICENSE.txt)
% (C) Copyright NoWork team

\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage[T1]{fontenc}

\title{NoWork\\
User manual}
\author{NoWork development team\\[2em]}
\date\today

\begin{document}
\maketitle


\section{Introduction}
%% Pierre
What is NoWork and why is it interesting with regards to other rewriting system?

\subsection{Rewriting system}
%% Rémy
Brief presentation of rewriting system in general.

\subsection{Getting started}
%% Vincent
How do we install it (with opam or from source), which program do I need to launch and where is it?

\section{\texttt{nowork --help}}
%% Vincent
Presentation of the nowork executable and the options.

\section{System language}
%% Matthieu
%% Presentation of the language (everything but the :command). A tutorial, example-oriented.
In this section, we will see how to describe a nominal rewriting
system for NoWork. Let us begin by showing the different options
offered by the language. Remember that the system is strongly typed.


\subsection{Kind}
Firstly, to describe our rewriting sytem, we have to describe types
manipulated by the system. Declarations of types are made using the
\verb?kind? keyword.\\
Since the system should be typed and we work on a \textbf{nominal}
rewriting system, types declared with \verb?kind? can be constructed using
\verb?type? for ``primary'' types and \verb?atom? for ``nominal''
types. We can defined parametrized type using \verb?->?. But,
constructions involving \verb?atom? and \verb?->? are (currently) forbidden.
To summarize, we have the following grammar :
\begin{verbatim}
primary-kind := type | type -> primary-kind

        kind := primary-kind | atom
\end{verbatim}

For example, some simple types :
\begin{verbatim}
kind Integer : type
kind List : type -> type
kind Couple : type -> type -> type
kind Var : atom
\end{verbatim}


\subsection{Constant}
Now that we can define types, we have to define the terms of a given type.
To define a term, we should first define constant of the rewriting
system.\\
Defining a constant is made by using the \verb?constant? keyword followed
by the name and the type. Be careful, the constant
type is the type of the constant for the rewriting system thus it must
be defined using \verb?kind? declarations. For example :

\begin{verbatim}
kind Integer : type

constant Zero : Integer
\end{verbatim}

To use parametrized type, we have to decide the abstraction it can be
either a generic type or a \verb?kind?.\\
To introduce a genericity, we should use the \verb?forall?
construction. Otherwise, to instantiate a type we should put the type
between angle brackets. For instance :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type
kind Couple : type -> type -> type

#generics
constant Nil : forall(A).List<A>
constant NilAssoc : forall(A,B).List<Couple<A,B>>

#instatiated
constant IntNil : List<Integer>
\end{verbatim}

\subsection{Operator}
In the same way that we did for constants, we define operators with the
\verb?operator? keyword. Operators take terms as arguments and terms
are constructed by composition between operators and constants :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

# A term can be :
# Hd(Tl(Cons(False, Cons(True, Nil))))

# but not :
# Cons(False, Cons(Zero, Nil))))
# because False and Zero does not have the same type
\end{verbatim}

\section{Rule}
Now, we want to declare rules used by the system to reduce a term.
The manner the system apply rules will be explained later using the
strategies.\\
As you would expect, we declare rule using the \verb?rule? keyword
followed by the rule's name and the term to rewrite and the term
rewrited. Such as types, we can declare generic terms in rules. This
genericity is made by using placeholder terms \verb!x?!. For example :
\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

rule [hd]:
  Hd(Cons(?x, ?y)) => ?x

rule [tl]:
  Tl(Cons(?x, ?y)) => ?y
\end{verbatim}


Thus, we have all the basis language needed to describe a nominal
rewriting system. With this we can design a system
corresponding to the Lambda Calculus or the Calculus of Communicating
Systems (CCS), for example.

\subsection{Semantics}
%% Rémy

\section{Strategy language}
%% Roven

\section{Interactive language}
%% Vincent
Presentation of the interactive language (:command).

\section{Example}
%% Roven
Present full program.

\subsection{lambda Calculus}

\subsection{CCS}


\end{document}
