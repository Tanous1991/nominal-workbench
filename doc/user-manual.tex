% Distributed under the MIT License.
% (See accompanying file LICENSE.txt)
% (C) Copyright NoWork team

\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage[T1]{fontenc}

\usepackage{hyperref}

\title{NoWork\\
User manual}
\author{NoWork development team\\[2em]}
\date\today

\begin{document}
\maketitle


\section{Introduction}
%% Pierre
What is NoWork and why is it interesting with regards to other rewriting system?

\subsection{Rewriting system}
%% Rémy
Brief presentation of rewriting system in general.

\subsection{Getting started}
%% Vincent
To install this program, you will need to get \emph{Opam}, the OCaml package-manager.
It can be downloaded at \url{http://opam.ocaml.org/doc/Quick_Install.html}

Once Opam is ready to use, you can have two possibilities. 

Either directly clone the project from github and install it :
\begin{verbatim}
# git clone https://github.com/ptal/nominal-workbench/
# cd nominal-workbench
# ./configure && make
\end{verbatim}

Or add the repository to your \emph{Opam} package list :
\begin{verbatim}
# opam repo add nowork git://github.com/pcouderc/nowork-repository
# opam install nowork
\end{verbatim}

There is a light emacs environment available in the \emph{data}
directory. Please refer to the emacs manual to install it in emacs.

\section{NoWork executable}
%% Vincent

The NoWork executable usage is : \texttt{nowork [options] <rules
  files>}.  A Read-Eval-Print-Loop (REPL) is launched if no arguments
are given. If \texttt{.nw} files are given the program will evaluate
each files sequentially and result in a REPL that contains an initial
environment based on the definitions found in the files.

The current options are :
\begin{itemize}
\item -{}-version -- Print version and exits
\item -{}-vnum -- Print version number and exits
\item -I <dir\_path> -- Include the given directory
\item -v -- Print more informations
\item -{}-no-repl -- Doesn't start a toplevel
\item -{}-debug -- Launch nowork in debug mode, the exception backtrace is reported
\item -{}-reset-system -- Doesn't keep the environment between each evaluated files
\item -{}-no-warning -- Doesn't print the warnings.
\item -{}-help -- Display the list of options
\end{itemize}

\section{System language}
%% Matthieu
%% Presentation of the language (everything but the :command). A tutorial, example-oriented.
In this section, we will see how to describe a nominal rewriting
system for NoWork. Let us begin by showing the different options
offered by the language. Remember that the system is strongly typed.


\subsection{Kind}
Firstly, to describe our rewriting sytem, we have to describe types
manipulated by the system. Declarations of types are made using the
\verb?kind? keyword.\\
Since the system should be typed and we work on a \textbf{nominal}
rewriting system, types declared with \verb?kind? can be constructed using
\verb?type? for ``primary'' types and \verb?atom? for ``nominal''
types. We can defined parametrized type using \verb?->?. But,
constructions involving \verb?atom? and \verb?->? are (currently) forbidden.
To summarize, we have the following grammar :
\begin{verbatim}
primary-kind := type | type -> primary-kind

        kind := primary-kind | atom
\end{verbatim}

For example, some simple types :
\begin{verbatim}
kind Integer : type
kind List : type -> type
kind Couple : type -> type -> type
kind Var : atom
\end{verbatim}


\subsection{Constant}
Now that we can define types, we have to define the terms of a given type.
To define a term, we should first define constant of the rewriting
system.\\
Defining a constant is made by using the \verb?constant? keyword followed
by the name and the type. Be careful, the constant
type is the type of the constant for the rewriting system thus it must
be defined using \verb?kind? declarations. For example :

\begin{verbatim}
kind Integer : type

constant Zero : Integer
\end{verbatim}

To use parametrized type, we have to decide the abstraction it can be
either a generic type or a \verb?kind?.\\
To introduce a genericity, we should use the \verb?forall?
construction. Otherwise, to instantiate a type we should put the type
between angle brackets. For instance :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type
kind Couple : type -> type -> type

#generics
constant Nil : forall(A).List<A>
constant NilAssoc : forall(A,B).List<Couple<A,B>>

#instatiated
constant IntNil : List<Integer>
\end{verbatim}

\subsection{Operator}
In the same way that we did for constants, we define operators with the
\verb?operator? keyword. Operators take terms as arguments and terms
are constructed by composition between operators and constants :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

# A term can be :
# Hd(Tl(Cons(False, Cons(True, Nil))))

# but not :
# Cons(False, Cons(Zero, Nil))))
# because False and Zero does not have the same type
\end{verbatim}

\section{Rule}
Now, we want to declare rules used by the system to reduce a term.
The manner the system apply rules will be explained later using the
strategies.\\
As you would expect, we declare rule using the \verb?rule? keyword
followed by the rule's name and the term to rewrite and the term
rewrited. Such as types, we can declare generic terms in rules. This
genericity is made by using placeholder terms \verb!x?!. For example :
\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

rule [hd]:
  Hd(Cons(?x, ?y)) => ?x

rule [tl]:
  Tl(Cons(?x, ?y)) => ?y
\end{verbatim}


Thus, we have all the basis language needed to describe a nominal
rewriting system. With this we can design a system
corresponding to the Lambda Calculus or the Calculus of Communicating
Systems (CCS), for example.

\subsection{Semantics}
%% Rémy

\section{Strategy language}
%% Roven

\section{Interactive language}
%% Vincent

We have at our disposition a toplevel interface that allows the user
to directly manipulate the system by introducing new rules, strategies
or terms. With this, the user is capable of interacting with the
system in a step-by-step manner. This can be use for some quick-hacks
or tests through a system that we would want to test or quickly-adding
some features to it.

This Read-Eval-Print-Loop (REPL) also contains a set of directives
that are useful for testing or debugging. A directive starts with a
column (:). The list can be quickly found by submitting a \emph{:help}
directive into the REPL.

We will proceed to the exhaustive description of every directive
present in NoWork.

\begin{itemize}
  \item :help -- Displays the help
  \item :exit -- Exits the REPL
  \item :dot <term> <"filename"> -- Outputs the hash-consed version of
    a term into a dot file graph
  \item :type <term> -- Displays the type of the term
\end{itemize}

There are also three more directives that requires some detailing.

\subsection{Testing directives}

First, we have the \emph{:test} directive. The syntax is : \emph{:test
  <term> <predicate> <result>}. This directive checks that the term
satisfies the predicate with the given result. The term denomination
is the same as the one given in the language description.

The predicates are : 
\begin{itemize}
\item \texttt{-{}-equals} -- Tests that the given term equals the resulting term.
\item \texttt{-{}-failwith} -- Checks that the given term fails with the
  given exception. They can be found in the \emph{data/error}
  directory of the project. More information about this to be found in
  the developper manual.
\end{itemize}

The second directives is \emph{:load-test <"filename"> [-{}-failwith
  <result>]}. It works very closely to the \emph{:test} directive but
takes a file instead of a term.

The last one checks that the given term matches either the given type
or the pattern structure. The syntax is : \emph{:match <term> -{}-with
  <pattern>} or \emph{:match <term> -{}-with-type <type>}.

Examples : 
\begin{verbatim}
:match App(Lambda(x, Var(x)), Lambda(y, Var(y))) 
       --with App(?T, ?T) 

:match Successor(Zero) --with-type Int
\end{verbatim}

\section{Example}
%% Roven
Present full program.

\subsection{lambda Calculus}

\subsection{CCS}


\end{document}
