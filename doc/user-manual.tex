% Distributed under the MIT License.
% (See accompanying file LICENSE.txt)
% (C) Copyright NoWork team

\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage[T1]{fontenc}

\usepackage{hyperref}
\usepackage{float}

\floatstyle{ruled}
\newfloat{program}{thp}{lop}
\floatname{program}{Program}

\title{NoWork\\
User manual}
\author{NoWork development team\\[2em]}
\date\today

\begin{document}
\maketitle


\section{Introduction}
%% Pierre
NoWork is a tool that allows to define languages as a set of
rewriting and term construction rules. The main goal of NoWork
is the experimentation with the principles of programming languages
specially with respect to the rewriting rules that define them.
NoWork is in that sense similar to the Maude system. However NoWork
incorporates the concept of strategy to define the way the
evaluation of the rules is performed over the structure of terms.

\subsection{Rewriting system}
%% Rémy
Brief presentation of rewriting system in general.

\subsection{Getting started}
%% Vincent
To install this program, you will need to get \emph{Opam}, the OCaml package-manager.
It can be downloaded at \url{http://opam.ocaml.org/doc/Quick_Install.html}

Once Opam is ready to use, you have two possibilities. 

Either clone the project directly from github and install it :
\begin{verbatim}
# git clone https://github.com/ptal/nominal-workbench/
# cd nominal-workbench
# ./configure && make
\end{verbatim}

Or add the repository to your \emph{Opam} package list :
\begin{verbatim}
# opam repo add nowork git://github.com/pcouderc/nowork-repository
# opam install nowork
\end{verbatim}

There is a light emacs environment available in the \emph{data}
directory. Please refer to the emacs manual to install it in emacs.

\section{NoWork executable}
%% Vincent

The command to execute NoWork is : \texttt{nowork [options] <rules
  files>}.  A Read-Eval-Print-Loop (REPL) is launched if no argument
is given. If \texttt{.nw} files are given the program will evaluate
each file sequentially and result in a REPL that contains an initial
environment based on the definitions found in the files.

The current options are :
\begin{itemize}
\item -{}-version -- Print version and exits
\item -{}-vnum -- Print version number and exits
\item -I <dir\_path> -- Include the given directory
\item -v -- Print more informations
\item -{}-no-repl -- Doesn't start a toplevel
\item -{}-debug -- Launch nowork in debug mode, the exception backtrace is reported
\item -{}-reset-system -- Doesn't keep the environment between each evaluated files
\item -{}-no-warning -- Doesn't print the warnings.
\item -{}-help -- Display the list of options
\end{itemize}

\section{System language}
%% Matthieu
%% Presentation of the language (everything but the :command). A tutorial, example-oriented.
In this section, we will see how to describe a nominal rewriting
system for NoWork. Let us begin by showing the different options
offered by the language. Remember that the system is strongly typed.


\subsection{Kind}
Firstly, to describe our rewriting sytem, we have to describe types
manipulated by the system. Declarations of types are made using the
\verb?kind? keyword.\\
Since the system should be typed and we work on a \textbf{nominal}
rewriting system, types declared with \verb?kind? can be constructed using
\verb?type? for ``primary'' types and \verb?atom? for ``nominal''
types. We can defined parametrized type using \verb?->?. But,
constructions involving \verb?atom? and \verb?->? are (currently) forbidden.
To summarize, we have the following grammar :
\begin{verbatim}
primary-kind := type | type -> primary-kind

        kind := primary-kind | atom
\end{verbatim}

For example, some simple types :
\begin{verbatim}
kind Integer : type
kind List : type -> type
kind Couple : type -> type -> type
kind Var : atom
\end{verbatim}


\subsection{Constant}
Now that we can define types, we have to define the terms of a given type.
To define a term, we should first define the constants of the rewriting
system.\\
Defining a constant can be done by using the \verb?constant? keyword followed
by the name and the type. Be careful, the constant
type is the type of the constant for the rewriting system so it must
be defined using \verb?kind? declarations. For example :

\begin{verbatim}
kind Integer : type

constant Zero : Integer
\end{verbatim}

To use a parameterized type, we have to decide the abstraction it can be
either a generic type or a \verb?kind?.\\
To introduce genericity, we should use the \verb?forall?
construction. Otherwise, to instantiate a type we should put the type
between angle brackets. For instance :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type
kind Couple : type -> type -> type

#generics
constant Nil : forall(A).List<A>
constant NilAssoc : forall(A,B).List<Couple<A,B>>

#instatiated
constant IntNil : List<Integer>
\end{verbatim}

\subsection{Operator}
In the same way that we did for constants, we define operators with the
\verb?operator? keyword. Operators take terms as arguments and terms
are constructed by composition between operators and constants :

\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

# A term can be :
# Hd(Tl(Cons(False, Cons(True, Nil))))

# but not :
# Cons(False, Cons(Zero, Nil))))
# because False and Zero does not have the same type
\end{verbatim}

\section{Rule}
Now, we want to declare rules used by the system to reduce a term.
The manner the system apply rules will be explained later using the
strategies.\\
As you would expect, we declare rule using the \verb?rule? keyword
followed by the rule's name and the term to rewrite and the term
rewrited. Such as types, we can declare generic terms in rules. This
genericity is made by using placeholder terms \verb!x?!. For example :
\begin{verbatim}
kind Integer : type
kind Bool : type
kind List : type -> type


constant True : Bool
constant False : Bool
constant Zero : Integer
constant Nil : forall(A).List<A>

operator Cons : forall(A).A * List<A> -> List<A>
operator Hd : forall(A).List<A> -> A
operator Tl : forall(A).List<A> -> List<A>

rule [hd]:
  Hd(Cons(?x, ?y)) => ?x

rule [tl]:
  Tl(Cons(?x, ?y)) => ?y
\end{verbatim}


Thus, we have all the basis language needed to describe a nominal
rewriting system. With this we can design a system
corresponding to the Lambda Calculus or the Calculus of Communicating
Systems (CCS), for example.

\subsection{Semantics}
%% Rémy

\section{Strategy language}
%% Roven

\section{Interactive language}
%% Vincent

We have at our disposition a toplevel interface that allows the user
to directly manipulate the system by introducing new rules, strategies
or terms. With this, the user is capable of interacting with the
system in a step-by-step manner. This can be use for some quick-hacks
or tests through a system that we would want to test or quickly-adding
some features to it.

This Read-Eval-Print-Loop (REPL) also contains a set of directives
that are useful for testing or debugging. A directive starts with a
colon (:). The list can be quickly found by typing the \emph{:help}
directive into the REPL.

We will proceed to the exhaustive description of every directive
present in NoWork.

\begin{itemize}
  \item :help -- Displays the help
  \item :exit -- Exits the REPL
  \item :dot <term> <"filename"> -- Outputs the hash-consed version of
    a term into a dot file graph
  \item :type <term> -- Displays the type of the term
\end{itemize}

There are also three more directives that requires some detailing.

\subsection{Testing directives}

First, we have the \emph{:test} directive. The syntax is : \emph{:test
  <term> <predicate> <result>}. This directive checks that the term
satisfies the predicate with the given result. The term denomination
is the same as the one given in the language description.

The predicates are : 
\begin{itemize}
\item \texttt{-{}-equals} -- Tests that the given term equals the resulting term.
\item \texttt{-{}-failwith} -- Checks that the given term fails with the
  given exception. They can be found in the \emph{data/error}
  directory of the project. More information about this to be found in
  the developper manual.
\end{itemize}

The second directive is \emph{:load-test <"filename"> [-{}-failwith
  <result>]}. It works very closely to the \emph{:test} directive but
takes a file instead of a term.

The last one checks that the given term matches either the given type
or the pattern structure. The syntax is : \emph{:match <term> -{}-with
  <pattern>} or \emph{:match <term> -{}-with-type <type>}.

Examples : 
\begin{verbatim}
:match App(Lambda(x, Var(x)), Lambda(y, Var(y))) 
       --with App(?T, ?T) 

:match Successor(Zero) --with-type Int
\end{verbatim}

\section{Example}
Figures ~\ref{fulllambda} and ~\ref{fullccs} contain two examples of
full programs written in NoWork. Building a program doesn't represent
any additional problem, it only consists in the aggregation of the terms, rules and
strategies that have been explained in the previous sections of this
manual.
%% Roven


\subsection{lambda Calculus}

\begin{verbatim}
  
kind Term : type
kind Variable : atom

operator Var : Variable -> Term
operator App : Term * Term -> Term
operator Lambda : [Variable]. Term -> Term
operator Subst : [Variable]. Term * Term -> Term

rule [beta] :
  App(Lambda(?x, ?T), ?U)  => Subst(?x, ?T, ?U)

rule [subst-var] :
  Subst(?x, ?T, Var(?x)) => ?T

rule [subst-nvar] :
  Subst(?x, ?T, Var(?y)) => Var(?y)

rule [app] :
  Subst(?x, ?T, App(?M, ?N)) => App(Subst(?x, ?T, ?M), Subst(?x, ?T, ?N))

rule [lambda] :
  Subst(?x, ?T, Lambda(?y, ?U)) => Lambda(?y, Subst(?x, ?T, ?U))


# extra rules for strategies

rule [dummy-replace] :
  Lambda(?x, ?Y) => Var(?x)

rule [is-subst] :
  Subst(?U, ?V, ?W) => Subst(?U, ?V, ?W)

rule [is-lambda] :
  Lambda(?x, ?T) => Lambda(?x, ?T)

rule [is-left-app] : 
  App(App(?x, ?y), ?U) => App(App(?x, ?y), ?U)

rule [is-right-lambda] :
  App(?x, Lambda(?y, ?U)) => App(?x, Lambda(?y, ?U))

rule [is-app-lambda-lambda] :
  App(Lambda(?x, ?Y), Lambda(?z, ?U)) => App(Lambda(?x, ?Y), Lambda(?z, ?U))

rule [is-app] :
  App(?U, ?V) => App(?U, ?V)

strategy IsValue :
  test([is-lambda])

strategy IsRightValue :
  test([is-right-lambda])

strategy IsLeftApp :
  test([is-left-app])

strategy IsApp :
  test([is-app])

strategy IsAppLambdaValue :
  test([is-app-lambda-lambda])

strategy Left(s) : proj(0, s)
strategy Right(s) : proj(1, s)

strategy Any(s) : 
  s +> one(Any(s))

strategy Test(p, s, b) : 
  test(p) ; s ; b

strategy While(p, s) :
  (test(p) ; s ; While(p, s)) +> id()

strategy TrySubst :
  [subst-var] +> [subst-nvar] +> [lambda] +> id()

strategy SubstAll :
  While(Any([is-subst]), Bottomup(TrySubst))

strategy Dummy :
    SubstAll ;
    (IsAppLambdaValue ; [beta]; Dummy) +>
    (IsApp ; Left(x) ; Right(Dummy)) +>
    id()
    
\end{verbatim}

\subsection{CCS}

\begin{verbatim}
kind Action : type
kind ActionName : atom

kind Process : type

constant Zero : Process
constant Tau : Action

operator In : ActionName -> Action
operator Out : ActionName -> Action

operator Prefix : Action * Process -> Process
operator Sum : Process * Process -> Process
operator Par : Process * Process -> Process

rule [choice-left] :
  Sum(?X, ?Y) => ?X

rule [choice-right] :
  Sum(?X, ?Y) => ?Y

rule [par-left] :
  Par(Prefix(?X, ?Y), ?Z) => Prefix(?X, Par(?Y, ?Z))

rule [par-right] :
  Par(?X, Prefix(?Y, ?Z)) => Prefix(?Y, Par(?X, ?Z))

rule [par-zero-right] :
  Par(?X, Zero) => ?X

rule [par-zero-left] :
  Par(Zero, ?X) => ?X

rule [match-par] :
  Par(?X, ?Y) => Par(?X, ?Y)

rule [match-sum] :
  Sum(?X, ?Y) => Sum(?X, ?Y)

strategy Any(s) : 
  s +> one(Any(s))

strategy While(p, s) :
  (test(p) ; s ; While(p, s)) +> id()

strategy Choice :
  [choice-left] + [choice-right]

strategy Par : 
  [par-left] + [par-right]

strategy BottomupRules :
  While(Any([match-par] +> [match-sum]),
    Bottomup(
      Choice +>
      Par +>
      [par-zero-right] +>
      [par-zero-left] +>
      id()
    )
  )
\end{verbatim}
  


\end{document}
